1. 数据结构分为逻辑结构和物理结构
   逻辑结构分为线性结构,集合,树和图
   物理结构分为顺序存储结构和链式存储结构
2. 线性表是线性结构的一种,顺序存储的线性表称为顺序表,链式存储的称为链表
   线性表是一组具有相同特性的元素的组成的有限序列,特点包括:序列,有限,无序,首部元素没有前驱元素,结尾元素没有后继元素,除此之外的其它元素
   都只有一个前驱和一个后继元素
   栈和队列都是线性表,只不过操作受限,栈只允许在同一端(头部)进行插入和删除操作,队列只允许在一端(尾部)插入数据,另一端删除数据(头部)
3. 图的存储包括邻接矩阵和邻接表
   邻接矩阵:一个一维数组存储顶点信息,一个二维数据(邻接矩阵)存储顶点之间的邻接关系
   邻接表:每个顶点建立一个链表,链表的头结点存储顶点信息,其它节点储存与顶点相连的边的信息,建立一个头结点结构的一维数组,头结点指向边信息
4. 二叉查找(搜索)树(Binary Search Tree, BST),又称二叉排序树,定义:它是一颗空树,或者是具有如下性质的二叉树:
   a> 节点左子树不为空,则左子树的值小于根节点的值;
   b> 节点右子树不为空,则右子树的值大于根节点的值;
   c> 节点的左右子树也都是二叉查找树
   d> 没有键值相等的节点
   显然,中序遍历二叉查找树,可以得到从小到大排序的输出(排序树),利用左子树值比根节点小,右子树值比根节点大的特性,又可以实现快速的查找功能(查找树,O(logN))
   二叉查找树的缺点是,但当插入的数据有序时,BST会退化为链表,此时查找的平均时间复杂度为O(N),查找效率会大大降低,因此若想获得最佳的查找性能,我们需要
   保证二叉查找树是平衡的,就这引出了带平衡条件的二叉查找树,二叉平衡树(Balanced Binary Tree)
5. 二叉平衡树(Balanced Binary Tree),又称AVL(Adelson-Velskii and Landis)树,得名于发明者G.M.Adelson-Velsky和E.M.Landis
   平衡二叉树很好的解决了二叉查找树退化成链表的问题,把插入,查找和删除的时间复杂度最好情况和最坏情况都保持在O(logN)
   定义:它是一棵空树,或者它的左右两个子树的高度差的绝对值不超过1,并且左右两棵子树都是一棵平衡二叉树
   平衡二叉树与普通二叉查找树的最大不同在于插入,删除的时候可能会改变树的平衡,并且从插入/删除的节点到根节点的路径上的所有节点的平衡性都有可能改变
   常见的四种不平衡情况:左左插入,左旋操作(画个图很容易推导);右右插入,右旋操作;左右插入,先t->left节点的右旋操作,再t节点的左旋操作
   右左插入,先t->right的左旋操作,再t节点的右旋操作
   归纳一下,左旋操作就是被旋转节点旋转为其右子节点的左子节点,旋转节点的新右子节点为原右子节点的左子节点,右旋操作刚好相反,被旋转节点旋转为其
   左子节点的右子节点,旋转节点的新右子节点为其原左子节点的右子节点,简而言之,左旋:节点变为其右孩子的左孩子;右旋:节点变为其左孩子的右孩子
   AVL是严格平衡的BST,所以它的查找时间复杂度是O(logN),且由于它避免了BST的退化,所以最差查找复杂度也是O(logN)
   由于要保持严格平衡,所以AVL的每一次插入都有可能要进行1次(最多1次)旋转(单旋或双旋),因此它的插入操作还是O(logN)
   同样的删除操作时,也需要旋转操作保持平衡,不过需要坚持从删除节点开始到根节点路径上所有节点的平衡因子,所以删除操作的代价较大,每次删除操作,最多
   需要O(logN)次旋转,所以删除操作的时间复杂度(查找+旋转)是:O(logN)+O(logN) = O(2logN)
   AVL是以牺牲建立严格平衡的BST为代价(插入和删除时的旋转操作),来保证O(logN)的查找时间复杂度,那么有没有一种折中方案,以较小的代价建立一种查找结构,
   同时还能保证高效的查找效率,这便引出了红黑树(Red-Black Tree)
6. 红黑树(Red-Black Tree),一种自平衡的二叉查找树,由Rudolf Bayer于1972年发明,在当时被称为对称二叉B树(symmetric binary B-trees)
   后来,在1978年被Leo J.Guibas和Robert Sedgewick修改为如今的红黑树,红黑树具有良好的效率,它能在O(logN)的时间内完成插入,删除和查找
   通过对任何一条从根节点到叶子节点的路径上各个节点的着色方式的限制,红黑树确保没有任何一条路径会比其他路径长出两倍(最多两倍),因而是接近平衡的
   红黑树是一种二叉查找树,所以首先要满足BST的一般性质,除此之外,还需要满足下面几点要求:
   a> 节点要么是红的,要么是黑的
   b> 根节点是黑的
   c> 每个叶子节点都是黑的(NIL节点,NULL节点)
   d> 每个红色节点的两个子节点都是黑色
   e> 从任一节点到其每个叶子节点的路径上包含相同数目的黑色节点(又称为黑高,未包含树尾的NIL节点)
   注:充当叶子节点的NIL节点和NULL节点,并不保存数据,只是表示已到达树的尾端
   红黑树之所以有这么高的效率,最重要是最后两条性质,对第四条性质翻译一下就是路径上不能有两个连续的红色节点,假如一棵红黑树的黑高为3,那么由最后两条
   性质可知,在具体的路径上,最多再插入两个红色节点,最短路径长度为3(全由黑色节点组成),则最长路径最大为5(3黑+2红),也即是没有任何一条路径是其它路径
   的两倍长(这种计算方式是包含黑色的叶子节点在内,如果路径长度不包含叶子节点,则最长路径长度刚好是最短路径的两倍)
   红黑树的插入,插入节点默认为红色,若为黑色,则该路径会增加黑高,调整起来比较麻烦,当插入红色时,不会影响黑高,只需要调整路径上连续两个红色节点即可
   调整连续红色节点,需要用到变色和旋转
   若插入节点N为红黑树的根节点,则执行变色操作,将该节点变为黑色即可
   若插入节点N的父节点P为黑色,则无需任何操作
   若插入节点N的父节点P为红色,则由性质d可知,插入节点的祖父节点G必为黑色,若插入节点的叔叔节点U为红色,执行变色操作,将P,U节点变为黑色,G节点变为红色
   变色操作后,G树满足所有性质,但仍需考虑G与其父节点形成连续的红色节点,故需要递归向上调整
   若插入节点N的父节点P为红色,叔叔节点U为黑色,且N是P的左孩子,P是G的左孩子(左左),此时对G进行右旋操作,并互换P与G的颜色即可
   若插入节点N的父节点为红色,叔叔节点U为黑色,且N是P的右孩子,P是G的左孩子(左右),可先对P执行左旋操作,变为左左结构,后边就是接着执行上一种情况的流程
   红黑树的删除
   待删除节点为子节点,字节删除即可
   待删除节点只有一个子节点,直接将待删节点的父节点相应的子节点指针指向其子节点即可
   待删除节点有两个非空子节点,找到左/右子节点中的最大/小节点值,覆盖该节点值,删除左/右子节点中的最大/小节点,再调整红黑平衡即可
   最后一种删除操作将删除情况简化,由双子转为叶子节点or单一子节点的删除,再由删除的子节点开始向根进行必要的调整,以满足红黑树的性质
   如果删除的是红色节点,那么它的父亲及儿子节点肯定都是黑色(性质d),则直接用黑色的儿子节点替换即可
   如果删除的是黑色节点,它的儿子节点是红色,则除了用儿子节点替换外,还需重绘儿子节点为黑色,如果不重绘黑色,有可能破坏性质d
   最复杂的是待删除节点为黑色,儿子节点也是黑色,这种情况需要考虑待删除节点的兄弟节点及其子节点的颜色,可能涉及到旋转和重绘,以下分类分析
   若儿子节点N顶替待删除的父节点P之后,为红黑树的根节点,则无需任何操作,根节点也是黑色,只不过所有经过根节点的简单路径黑高都减1而已
   若儿子节点N的新的父亲节点P(原来的祖父节点G)为红色,且兄弟节点S(原来的叔叔节点)及S的两个子节点SL,SR都为黑色,则只需交换P与S的颜色即可
   这样原来经过S的简单路径的黑高不变,经过N的简单路径的黑高也保持不变(删除后重绘前,经过N的简单路径黑高减1,父节点由红->黑,再次保证黑高不变)
   节点N的兄弟节点S为黑色,SL为黑色,SR为红色,则对P节点进行左旋,并交换P与S的颜色,此时可保证S->P->N/SL路径上的黑色节点不变,但是由于S的黑色
   给了P,则SR路径上的黑色节点数少了1个,为了保证平衡,再将SR由红色重绘为黑色即可
   节点N的兄弟节点S为黑色,SL为红色,SR为黑色,这种情况将节点S右旋,互换S与SL的颜色,则就回到了上面一种情况,S,SL为黑,SR为红,接着执行上一种情况的操作即可
   若兄弟节点S为红色,由性质d可知,SL,SR均为黑色,此时以P节点左旋,并互换P与S的颜色,则此时对N节点而言,有可以对应上面的三种情况,即它有一个红色的父亲节点P
   有一个黑色的兄弟节点SL,此时再考察SL的两个子节点的红黑情况,对照上面的三种情况分别处理即可
   参考:https://github.com/julycoding/The-Art-Of-Programming-By-July/blob/master/ebook/zh/03.01.md
7. 2-3-4树,是一种阶为4的B树,它也是一种自平衡的数据结构,可以在O(logN)的时间复杂度内完成查找,插入和删除操作
   2-3-4树的名字是根据子节点数来确定的,任意一个节点都只能是2node,3node,4node中的一个,相比二叉树,2-3-4树扩展了节点中key的数量
   2node 含有一个key值,两个子节点; 3node 含有两个key值,三个子节点; 4node 含有三个key值,四个子节点;
   2-3-4树的子树:对于2node而言,左子树小于key,右子树大于key; 对于3node而言,左子树小第一个key,中间子树比第一个key大,比第二个key小
   右子树比第二个key大; 对于4node,各子树的大小以此类推
   2-3-4树,所有的叶子节点都在最后一层,且2-3-4树可以保持完美平衡,所有叶子节点的深度都是一样的
   2-3-4树的查找,与BST一样,根据与节点key值的比较,确定查找路径
   2-3-4树的插入,待插入节点是2node,则直接把它转换成3node即可; 如果待插入节点是3node,直接转换为4node; 如果待插入的是4node,则需要先对其进行
   分裂操作,具体是先将4node的中间的key向上移动,移动到父节点中(改变父节点结构),其次将新生成的3node再分裂为两个2node,最后再执行此次插入操作
   为啥要将新生成的3node再分裂为两个2node? 新生成的3node也可以完成当次插入操作,不过就有可能导致插入后的4node的父节点也是4node,那么就会影响
   下次的插入操作,因为2-3-4树只有3类节点,若路径上有连续两个4node,则下次插入操作时无法提升中间key,切分4node节点,一旦向上提升key,父节点的4node
   必定会出现超过3个key的节点,这样新的父节点不符合2-3-4树的定义,将新生成的3node再分裂为两个2node,就是为了确保路径上不会有连续两个4node
   2-3-4树的具体实现比较麻烦,首先是节点类型比较多;其次插入操作,可能会有大量的4node切分;最后是在插入,删除操作过程中节点类型多变
   补一篇从2-3-4树到红黑树的参考:https://www.jianshu.com/p/37c845a5add6
8. B树,又称B-树(Balanced Tree),B树是一种m叉的平衡查找树,B树与红黑树类似,但在降低磁盘I/O操作方面要更好,许多数据库系统都使用B树或其变种来存储信息
   BST,AVL,红黑树都是典型的二叉查找树,查找效率和树的高度相关,那么在遇到大规模数据的时候,如果采用上述结构将会造成二叉树的高度过大,查找将变为节点
   之间的线性查找,同时大规模数据将会频繁调用磁盘的I/O读写,这两个方面都会降低查询效率,那么很自然的想到通过增加子节点个数来降低树的高度,这就是B树
   B树中所有节点孩子节点的最大数称为B树的阶,通常用m表示,从查找效率考虑,一般要求m>=3,一颗m阶B树要么是一颗空树,要么是满足以下性质的m叉树:
   a> 每个节点最多有m个子节点,最小分支则要看是否是根节点,如果是根节点且非叶子节点,则至少有两个子节点,非根非叶节点至少有ceil(m/2)个子节点
   b> 非叶节点有n个关键字,那么该节点有n+1个子节点,且n个关键字按递增顺序排列,非叶节点的结构为(n,p0,k1,p1,k2,p2,...,kn,pn)
      n为关键字个数,p0指针指向的子节点的关键字小于k1,pn所指的子节点的关键字大于kn,pi所指的子节点关键字大于ki且小于ki+1
      含有m个分支的节点拥有的关键字个数为m-1,通常来说关键字个数n需满足:ceil(m/2)-1 <= n =< m-1
   d> 所有叶子节点都位于同一层,可用空指针表示,表示查找失败到达的位置
   B树的插入:根据要插入值,找到叶子节点,并插入; 判断当前节点的key个数是否小于m-1,若满足则结束,否则进入下一步; 以当前节点的中间的key为中心
   分裂成两个子树,将中间的key插入父节点,该key的左子树指针指向新生成的左边部分,右子树指针指向右边部分,将当前指针指向父节点,再执行上一步的操作
   判断新的当前节点的key个数是否大于m-1,循环执行直至所有的节点满足B树的性质
   B树的删除:如果要删除的key在非叶节点,则与二叉树类似,后后继key覆盖,再删除后继key,最后删除的key一定位于叶子节点上; 判断当前删除节点的key个数
   是否大于等于ceil(m/2)-1,如果是则删除操作结束,否则进入下一步; 判读当前节点的兄弟节点(左或右)key的个数是否大于ceil(m/2)-1,如果大于则将父节点
   下沉到当前节点,相应的兄弟节点中的一个key值(一般是最右边的key)升入父节点,删除操作结束,否则将父节点中的key下移与当前节点及其相应的兄弟节点
   合并成一个新节点,父节点中下移的key的左右指针变为一个指针,并指向新生成的节点,当前节点指向原来的父节点,重复第二步
9. B+树,是应文件系统所需而产生的一种B树的变形树(文件的目录一级一级索引,只有最底层的叶子节点保存数据,非叶节点只保存索引),B+树除了B树的性质之外
   还有如下的特性:
   a> 非叶节点的子树指针与关键字个数相同
   b> 非叶节点的子树指针pi指向的是闭区间[ki,ki+1],B树是开区间,且B树不允许关键字重复,而B+树允许重复
   c> 为所有叶子节点加一个链指针(所有叶子节点组成一个链表)
   d> 所有关键字都在叶子节点中出现,且数据有序(遍历叶子节点即可顺序输出,同时遍历整棵树也只需要遍历叶子节点)
   mysql索引采用B+树的主要原因是,B树在提高I/O性能的同时,没有解决元素遍历效率低下的问题,而B+树只需要遍历叶子节点就可以实现整棵树的遍历,同时在数据库
   总基于范围的查询(区间查询)比较频繁,而B树的效率太低,因为B树的非叶节点也存储有数据,此时若要找到具体的数据,则必须执行中序遍历操作
   B+树的插入:若为空树,创建一个叶子节点,将值插入节点,操作结束; 非空,则根据要插入的key值找到相应的叶子节点,向节点插入,判断节点key的个数是否小于
   或等于m-1,满足则操作结束,否则将该叶子节点分裂为左右两个子节点,左子节点包含前m/2个key及其值,右子节点包含剩余的key和记录,同时将第m/2+1个key升入
   父节点,并指向分裂的两个子节点,将当前节点的指向升入的父节点(索引节点),执行下一步; 若当前节点key的个数小于等于m-1,则操作结束,否则将这个索引节点
   分裂为两个索引节点,左索引节点包含前m/2-1个key,第m/2的key升入父节点,右索引节点指向剩余的key,再将当前节点指向父节点,重复本步骤
   B+树的删除操作与B树的删除类似:叶子节点没有相应的key,则删除失败; 叶子节点删除key,判断key的个数是否大于等于ceil(m/2)-1,大于则操作结束,否则进入
   下一步; 若兄弟节点有富余(key个数大于等于ceil(m/2)-1),则去兄弟节点的最大key升入父节点,父节点key下沉到删除节点,操作结束,若左右兄弟节点都不富余
   进入下一步; 当前节点和兄弟节点合并为新节点,并删除父节点中的key,当前节点指向父节点,判断当前节点key的个数,重复上述操作直至满足B+树的性质
   参考:https://www.cnblogs.com/tiancai/p/9024351.html  https://www.cnblogs.com/nullzx/p/8729425.html
10. B*树,是B+树的变种,与B+树的区别,主要有以下两点
    a> 节点关键字个数限制,B+树的关键字初始化个数为ceil(m/2),B*树的初始化个数为ceil((2/3)m)
    b> B+树节点满时就会分裂,而B*树节点满时会先检查兄弟节点是否已满(每个节点都有指向兄弟节点的指针),如果兄弟节点未满,则向兄弟节点转移关键字
       如果兄弟节点已满,则从当前节点和兄弟节点各取1/3的数据,组件一个新的节点
    在B+树的基础上,节点(非叶节点)保存兄弟节点的指针,且可向兄弟节点转移关键字的特性,使得B*树的分裂次数变得更少
11. 堆(Heap), 堆结构本质是一颗完全二叉树,是用数组实现的二叉树,堆常用于堆排序,构建优先队列,找出集合中的最大/小/前K个值(Top K算法的其中一种实现方法
   就是构建大/小顶堆,特别是海量数据规模的时候仍然适用,可有效避免无法一次性读取全部数据)
   堆一般要满足以下两个性质:堆中节点的值不大于or不小于其子/父节点的值(嵌套定义,子堆满足相同的大小规律); 堆总是一颗完全二叉树
   基于以上性质,有两种堆类型,大顶堆(父节点的值大于子节点的值),小顶堆(父节点的值小于子节点单独值)
   堆与BST的区别:
   在BST中,左子节点比父节点小,右子节点比父节点大,大小顺序满足:左 < 根 < 右, 但在堆中只定义了子节点比父节点大/小,左右子堆并无确定的大小关系
   BST or 其它树结构,需要分配额外的空间存储左右子树,堆使用数组存储数据,且不使用指针
   BST需在平衡的条件下,其大部分的操作时间复杂度才能达到O(logN),要不然就得使用AVL树或者红黑树,而在堆中不存在平衡问题,只要满足堆属性,就能保证O(logN)
   BST搜索很快,而在堆中搜索就很慢,毕竟堆的第一优先级不是搜索
   由于堆是有数据实现的完全二叉树,所以堆有如下属性:
   第N个节点的父节点索引是floor(N/2); 第N个节点的左孩子的索引是2N,右孩子索引是2N+1; N个节点的堆,高度h = floor(log2(N)),因为堆要求每一层的节点
   全部填充满了之后,才能开辟下一层(堆高h不包括根节点那一层); 如果高度为h的层已被填满,则该层元素个数为2^h,前h-1层所有元素的个数为2^h - 1,堆中所有
   元素的个数为2^(h+1) - 1;
   以大顶堆为例说明堆的插入和删除,为了在插入和删除数据之后,保持堆属性,用到了两个操作shiftUp(),shiftDown(),分别如下:
   在插入时,将插入元素放到最后一层的第一个空位,为了保持大顶堆的性质,比较新插入数据与父节点(floor(N/2))的大小,如果比父节点大,则将二者进行交换,
   重复上述操作直到父节点比它大或者已到达根部,这就是shiftUp()操作
   删除操作与插入相反,我们可以去最后一个元素,覆盖到待删除节点,再从待删除节点调整堆,与两个子节点的值比较,若子节点都比父节点的值大,则与其中较大的
   子节点互换位置,重复操作,直到子节点都比父节点小,或者已达到堆底,这就是shiftDown()操作,不错删除操作不一定只有shiftDown(),也有可能用到shiftUp(),
   比如删除最后一层最左边的元素,此时先用同层最右边的元素替换,然后就可能要执行shiftUp()操作了
12. 图是一种复杂的非线性结构,在线性结构中,数据元素之间满足唯一的线性关系,数据元素(除第一个和最后一个)只有一个直接前驱和一个直接后继,在树形结构中
   数据元素之间存在明显的层次关系,每个元素只与上层的一个元素和下层的多个元素有关联,而在图结构中,任意两个元素之间都有可能相关
   图有两个集合V(Vertex,顶点集合)和E(Edge,边集合)组成,定义为:G=(V,E)
   图按有无方向分为无向图和有向图,无向图由顶点和边组成,有向图由定点和弧组成,弧有弧头和弧尾之分
   如果任意两个顶点之间都有边,则叫完全图,边或弧上是否有权值,又分为无权图和有权图
   无向图顶点的边数叫度,有向图则分为入度和出度
   图中两顶点之间存在路径则是连通的,如果路径最终回到初始点则称为环,路径中不重复则称为简单路径,若任意两顶点都是连通的则称为连通图,有向则称为强连通图
   图有子图,若子图极大连通就是连通分量,有向则为强连通分量
   无向图连通且n个顶点n-1条边,叫做生成树,有向图中一个顶点入度为0,其余顶点入度为1,叫做有向树
   图相关的常见知识点包括:遍历(BFS,DFS),最小生成树(Prim算法,Kruskal算法),最短路径(Dijkstra算法,Floyd算法)
13. 图的遍历:从图中某个顶点出发,访问图中的其它顶点,且每个顶点只访问一次,图的遍历主要有两种方法广度优先搜索(Breadth First Search,BFS)和深度优先搜索
   (Depth First Search,DFS)
   广度优先的遍历规则是:先访问当前顶点的所有未访问过的邻接顶点,再依次访问邻接顶点的未被访问过的邻接顶点,广度优先需要用到辅助队列
   深度优先的遍历规则是:不断沿着顶点的深度方向遍历(深度方向指它的邻接点方向),直到最后一个顶点,然后回溯,找到路径上未被访问的一个邻接点,继续深度遍历
