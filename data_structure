1. 数据结构分为逻辑结构和物理结构
   逻辑结构分为线性结构,集合,树和图
   物理结构分为顺序存储结构和链式存储结构
2. 线性表是线性结构的一种,顺序存储的线性表称为顺序表,链式存储的称为链表
   线性表是一组具有相同特性的元素的组成的有限序列,特点包括:序列,有限,无序,首部元素没有前驱元素,结尾元素没有后继元素,除此之外的其它元素
   都只有一个前驱和一个后继元素
   栈和队列都是线性表,只不过操作受限,栈只允许在同一端(头部)进行插入和删除操作,队列只允许在一端(尾部)插入数据,另一端删除数据(头部)
3. 图的存储包括邻接矩阵和邻接表
   邻接矩阵:一个一维数组存储顶点信息,一个二维数据(邻接矩阵)存储顶点之间的邻接关系
   邻接表:每个顶点建立一个链表,链表的头结点存储顶点信息,其它节点储存与顶点相连的边的信息,建立一个头结点结构的一维数组,头结点指向边信息
4. 二叉查找(搜索)树(Binary Search Tree, BST),又称二叉排序树,定义:它是一颗空树,或者是具有如下性质的二叉树:
   a> 节点左子树不为空,则左子树的值小于根节点的值;
   b> 节点右子树不为空,则右子树的值大于根节点的值;
   c> 节点的左右子树也都是二叉查找树
   d> 没有键值相等的节点
   显然,中序遍历二叉查找树,可以得到从小到大排序的输出(排序树),利用左子树值比根节点小,右子树值比根节点大的特性,又可以实现快速的查找功能(查找树,O(logN))
   二叉查找树的缺点是,但当插入的数据有序时,BST会退化为链表,此时查找的平均时间复杂度为O(N),查找效率会大大降低,因此若想获得最佳的查找性能,我们需要
   保证二叉查找树是平衡的,就这引出了带平衡条件的二叉查找树,二叉平衡树(Balanced Binary Tree)
5. 二叉平衡树(Balanced Binary Tree),又称AVL(Adelson-Velskii and Landis)树,得名于发明者G.M.Adelson-Velsky和E.M.Landis
   平衡二叉树很好的解决了二叉查找树退化成链表的问题,把插入,查找和删除的时间复杂度最好情况和最坏情况都保持在O(logN)
   定义:它是一棵空树,或者它的左右两个子树的高度差的绝对值不超过1,并且左右两棵子树都是一棵平衡二叉树
   平衡二叉树与普通二叉查找树的最大不同在于插入,删除的时候可能会改变树的平衡,并且从插入/删除的节点到根节点的路径上的所有节点的平衡性都有可能改变
   常见的四种不平衡情况:左左插入,左旋操作(画个图很容易推导);右右插入,右旋操作;左右插入,先t->left节点的右旋操作,再t节点的左旋操作
   右左插入,先t->right的左旋操作,再t节点的右旋操作
   AVL是严格平衡的BST,所以它的查找时间复杂度是O(logN),且由于它避免了BST的退化,所以最差查找复杂度也是O(logN)
   由于要保持严格平衡,所以AVL的每一次插入都有可能要进行1次(最多1次)旋转(单旋或双旋),因此它的插入操作还是O(logN)
   同样的删除操作时,也需要旋转操作保持平衡,不过需要坚持从删除节点开始到根节点路径上所有节点的平衡因子,所以删除操作的代价较大,每次删除操作,最多
   需要O(logN)次旋转,所以删除操作的时间复杂度(查找+旋转)是:O(logN)+O(logN) = O(2logN)
   AVL是以牺牲建立严格平衡的BST为代价(插入和删除时的旋转操作),来保证O(logN)的查找时间复杂度,那么有没有一种折中方案,以较小的代价建立一种查找结构,
   同时还能保证高效的查找效率,这便引出了红黑树(Red-Black Tree)
6. 红黑树(Red-Black Tree),一种自平衡的二叉查找树,由Rudolf Bayer于1972年发明,在当时被称为对称二叉B树(symmetric binary B-trees)
   后来,在1978年被Leo J.Guibas和Robert Sedgewick修改为如今的红黑树,红黑树具有良好的效率,它能在O(logN)的时间内完成插入,删除和查找
   通过对任何一条从根节点到叶子节点的路径上各个节点的着色方式的限制,红黑树确保没有任何一条路径会比其他路径长出两倍(最多两倍),因而是接近平衡的
   红黑树是一种二叉查找树,所以首先要满足BST的一般性质,除此之外,还需要满足下面几点要求:
   a> 节点要么是红的,要么是黑的
   b> 根节点是黑的
   c> 每个叶子节点都是黑的(NIL节点,NULL节点)
   d> 每个红色节点的两个子节点都是黑色
   e> 从任一节点到其每个叶子节点的路径上包含相同数目的黑色节点(又称为黑高)
   注:充当叶子节点的NIL节点和NULL节点,并不保存数据,只是表示已到达树的尾端
   红黑树之所以有这么高的效率,最重要是最后两条性质,对第四条性质翻译一下就是路径上不能有两个连续的红色节点,假如一棵红黑树的黑高为3,那么由最后两条
   性质可知,在具体的路径上,最多再插入两个红色节点,最短路径长度为3(全由黑色节点组成),则最长路径最大为5(3黑+2红),也即是没有任何一条路径是其它路径
   的两倍长
   参考:https://github.com/julycoding/The-Art-Of-Programming-By-July/blob/master/ebook/zh/03.01.md
7. 2-3-4树,是一种阶为4的B树,它也是一种自平衡的数据结构,可以在O(logN)的时间复杂度内完成查找,插入和删除操作
   2-3-4树的名字是根据子节点数来确定的,任意一个节点都只能是2node,3node,4node中的一个,相比二叉树,2-3-4树扩展了节点中key的数量
   2node 含有一个key值,两个子节点; 3node 含有两个key值,三个子节点; 4node 含有三个key值,四个子节点;
   2-3-4树的子树:对于2node而言,左子树小于key,右子树大于key; 对于3node而言,左子树小第一个key,中间子树比第一个key大,比第二个key小
   右子树比第二个key大; 对于4node,各子树的大小以此类推
   2-3-4树,所有的叶子节点都在最后一层,且2-3-4树可以保持完美平衡,所有叶子节点的深度都是一样的
   2-3-4树的查找,与BST一样,根据与节点key值的比较,确定查找路径
   2-3-4树的插入,待插入节点是2node,则直接把它转换成3node即可; 如果待插入节点是3node,直接转换为4node; 如果待插入的是4node,则需要先对其进行
   分裂操作,具体是先将4node的中间的key向上移动,移动到父节点中(改变父节点结构),其次将新生成的3node再分裂为两个2node,最后再执行此次插入操作
   为啥要将新生成的3node再分裂为两个2node? 新生成的3node也可以完成当次插入操作,不过就有可能导致插入后的4node的父节点也是4node,那么就会影响
   下次的插入操作,因为2-3-4树只有3类节点,若路径上有连续两个4node,则下次插入操作时无法提升中间key,切分4node节点,一旦向上提升key,父节点的4node
   必定会出现超过3个key的节点,这样新的父节点不符合2-3-4树的定义,将新生成的3node再分裂为两个2node,就是为了确保路径上不会有连续两个4node
